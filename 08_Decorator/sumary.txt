- a decorator keeps the reference to the decorated object(s)
- may or may not proxy over calls, meaning that it may or not replicate the API of the original object
- resharper helps you generate delegated members which is very conveninent
- you cannot cast the decorator to the orginal object
- in c#Â the decorator also exists in the static variation, which means that the layering of thecorator is not by calling their constructors but by specifying a type with generic arguments
 - X<Y<Foo>>
 - very limited in C# due to inhability to inherit from type parameters, you cannot have the type Foo<T> (this is read as "type Foo of T") inheriting from T